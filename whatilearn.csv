02789,string만으로 for문 돌리기/to_string은 int를 string으로 바꾸는 것:
05717,done
07891,done
11006,기존 int로 for문 돌리기
14645,반복문
20332,done
20361,for문에 for문 내에 써야할 변수는 쓰지 말껏(반복 횟수에 영향을 줌)
20673,done
06376,분수 계산후 형 변환시 분수 감싸지 말것(int로 되버림)/cout.precision(n):cout에서 소수점자리를 최대 n자리 까지 출력/cout.setf(ios::showpoint);소수점 뒷자리의 0표시
10419,sqrt 함수는 cmath 라이브러리에 있음
01731,일반array는 append 불가/append하고 싶으면 vector로 만들고 push_back()/n번 반복을 --로 구현할시 (n;n>0;n--)
02386,string으로 뛰어쓰기 있는 문장 입력하고 싶으면 getline이용/string을 소문자로 바꿀 경우 algorithm에 있는 transform을 이용할수 있음;이때 tolower앞에 반드시 ::붙일것
03047,char로 문자열 받을 경우 반드시 칸수를 (문자열길이)+1으로 할 것
05704,char도 증감 연산 가능/string에서 문자 수를 셀때는 algorithm에 있는 count 함수 이용
01264,count  함수
06322,cout << fixed; 소숫점 자리만 precision 함수를 먹도록 함.
05032,none?
02736,string length
02744,c++에 python의 swapcase 명령어는 없음. 그러나 그 외의 tolower나 islower 같은 명령어는 있음.
01568,증감연산자를 조건문 등에서 조건으로 쓰지 말것.조건에서도 식이 계산되버림.
01094,나눗셈으로도 for문을 돌릴수 있음.
02145,%연산자는 반드시 int 끼리만 연산 가능.cmath의 log10를 이용하면 쉽게 숫자의 자리수를 알 수 있음. 
01259,string을 이등분하게 되면 length가 짝수일시 0~len/2와 len/2+1~len-1로;홀수일시 0~len/2-1와 len/2+1~len-1
02869,c++에서 0.xx초는 반복문을 넣지만 않으면 조건문 몇개정도는 충분히 돌아간다.
01574,20361과 동일
02953,none
05054,배열등에서의 최대값이나 최솟값은 algorithm에 있는 *max;min_elements 함수를 이용한다.
02798,브루트포스=노가다/c++이면 100c3면 삼중 for문 해도 1ms가 날까 말까 임으로 그냥 노가다로 풀자.
02484,*max_elements 함수를 쓸때 int 배열이면 a;;a+n으로 활용한다.
09655,none
01684,string을 비교할시에는 작은 따옴표 대산 큰 따옴표 로 문자열을 감싸야 한다
11320,큰 정삼각형 안에 들어가는 작은 삼각형의 개수:(두 삼각형 변의 비)^2
06559,배열도 string 식으로 for문을 돌릴수 있음.
02739,none
10833,none
10818,vector는 좀...많이 느리다
13866,괄호만 씌어준다면 cout에서도 삼항연산자를 사용 할 수 있다.
02495,none
09498,none
11728,cin은 int 일시 개행을 해도 구분 되어 넣는다. 따라서 여러줄을 for문으로 받을수 있다/cin.tie(0);cout.tie(0);ios::sync_with_stdio(0); 로 cin과 cout의 속도를 늘릴수 있다. 딘 scanf하고 printf;; gets;; puts하고 혼용하면 안됨.
02902,none
01271,10^1000승은 c++에서는 정수로 처리할수 없다. 파이썬을 써야 한다
01001,(go)string으로 박고 int로 바꾸는게 더 빠를수도
01001,(py)2개를 한번에 받을때 반드시 string으로 받아야 오류가 나지 않는다
15552,01271번의 cin/cout을 최적화하는 방법을 쓰면 scanf/printf 보다 더 빠르다
02010,none
02884,시간 계산
01546,11728과 동일
02525,시간을 더할때 1440분 이하면 시간을 정리할때 한번만 확인해도 된다.
02588,stoi:string to int
04344,%를 출력하려면 %%로 입력해야 한다
04447,getline으로 문제가 일어나면 getchar로 엔터를 한번 빼주거나 cin.ignore();로 엔터를 무시해줄껏
10930,c++로 md5값을 네이티브로 얻는것이 가능은 하다. 코드가 너무 복잡할뿐
10797,none
10808,none
02941,for문의 변수는 for문 안에서 추가적으로 변경해줄수 있다. 이를 이용해 특정 문자열을 띄어 넘을 수 있다.
01010,조합 계산시 c++은 공식을 재귀로 구현;;python은 math의 comb 함수를 이용할 것
05585,raspberrypi test
10869,none
10430,NONE
04072,단어만 뒤집기:cin으로 단어 단위로 받은 후 reverse 함수 이용/for문으로 뒤에서부터 출력하나 reverse를 이용하나 걸리는 시간은 똑같다.
01193,등차가 1씩 증가하는 배열에서 몇번쨰 찾기:등차의 합 이용
11720,none
15184,(char)를 이용하면 정수를 ascii 코드로 대입하여 출력 할 수 있다./{0;;}으로 배열을 0으로 채울 수 있다.
10809,특정 정수로 배열 채우기:algorithm에 fill_n 이용/for(int a:b)로 정수 배열을 반복할수 있다.
02167,cin속도를 높이는 방법을 사용하면 메모리도 약간 감소한다.
10804,c 배열의 a번째부터 b번째 reverse:reverse(c+(a-1);;c+b)
01551,구분이 공백이 아니면 getline으로 받은후 stoi를 사용한다.
02577,none
02711,none
01157,return 0을 사용해 for문등에서 뒤에 명령들을 수행 하지 않고 종료 시킬 수 있다.
03052,none
02530,%=연산자가 있어 나누는 코드를 줄일 수 있다.
02775,재귀로 구해야 할 것 같은 문제들은 주어진 행이 아닌 구해야 하는 행의 주변을 중심으로 생각해볼껏.
15596,백준에서 함수를 만드는 문제의 경우 제출할 시 가이드 라인이 나온다.for문은 생각보다 빠르다...
02839,특정수들로 몇 번 나눠야 하는지 묻는 이런 문제들은 그냥 while문으로 풀자....
11966,int:2^31/long long:2^63
01159,none
10984,none
02845,none
09012,큐나 스택같은 문제는 문자열을 추가하고 지울수 있는 string의 성질을 이용하면 쉽게 풀 수 있다/string에 char를 더할때는 그냥 a+=b 형식으로 추가 하면 된다.
02292,최소 거리를 구하기 위해 for문을 돌릴시 값을 증가시키기 전에 if문으로 다시 검사할것.
02748,피보나치 수열 빨리 구하는 방법/log2로 int를 써야하는지;;long long을 써야하는지 판별 가능.
02338,(py)정수를 한줄에 하나씩 받으면 int(input())을;;한줄에 두개 이상 받으면 map(int;;input().split())
14209,계산에 필요 없는 수들을 continue 시켜줘도 걸리는 시간은 continue를 시키지 않은 것과 거의 같다.
02455,none
03053,pi가 필요한 문제는 cmath의 M_PI이용할것/택시 기하학에서의 원의 넓이:2*r*r
01934,최소 공배수=(두 값의 곱)/(최대 공약수);/최대공약수는 %를 while문으로 돌림으로써 구할수 있음.
03059,none
09310,--제발 c++도 bigint 지원좀--
03040,none
05622,none
02309,정답이 여러 가지인 경우에는 아무거나 출력하라==하나만 출력 하라.
03004,n번변에 평행히 잘랐을때 최대 조각 개수:(N/2+1)*(N/2+1+N%2))
01284,none
02501,none
01037,모든;;혹은 1과 n을제외한 약수들이 주어졌을때 n구하기:최댓값*최솟값
02442,별찍기 같은 문제를 풀때 출력 형식 오류가 뜨면 0번째에 무조건 공백이 생기는지 확인할것.
14592,none
18301,none
01333,이와 같은 문제는 2중 for문으로 푼다.
07481,02839를 이용하면 아주 쉽게 풀 수 있다.
15829,(py)ord():char to ascii
05596,?연산자의 : 전후로 cout 같은 명령어 1개 정도를 집어넣을 수 있다.
04153,iostream만 include 하여 길게 작성하던;; algorithm등 여러가지를 include 하여 여러 명령어를 사용하던 실행속도나 메모리 면에서 차이가 거의 없다.
01297,비율이 a:b일때 인치수로 높이나 너비 구하기:(a||b)*(인치)/sqrt(a^2+b^2)/이때 sqrt부분은 반드시 실수형 이여야 만 함
19532,연립방정식 ax+by=c&&dx+ey=f 일때 x=(c*e-b*f)/(a*e-b*d);y=(c*d-a*f)/(b*d-a*e);
02675,none
03009,이 문제와 같이 적은 빈도수를 찾는 문제에서는 ^=(xor 연산)으로 코드를 간단히 풀 수 있다.
02920,none
01769,none
11382,none
02480,세 수 a/b/c에서의 최대값 구하기:(a>b ? a>c ? a : c : b>c ? b : c)
01373,string 자체는 iostream만 include 해도 쓸 수 있다.
14652,none
01225,한 자리수 씩 연산을 해야 할때에는 그냥 string으로 받은후 for문을 돌리면 된다.
02908,none
13235,none
03460,none
15080,초 계산:c>d?cout<<(3600*24-c)+d<<"\n":cout<<d-c<<"\n";
18406,none
05543,3개의 값 중 최솟값 찾기:a[0]>a[1]?(a[1]>a[2]?a[2]:a[1]):(a[0]>a[2]?a[2]:a[0]);
14910,변수의 개수가 주어지지 않을 경우 while문에 scanf()!=EOF나 무한 루프 후 마지막에 if(cin.eof()==1)를 넣어서 해결할 수 있다. 단;;이 경우 터미널 등에서 돌릴떄는 윈도우에서는 ^Z;;unix에서는 ^D로 종료시켜야 한다.이는 백준에서는 파일로 채첨해 EOF가 들어가 있지만 터미널에서는 들어가 있지 않기 때문이다.
10039,none
10822,find는 찾을것이 없으면 string::npos를 리턴한다. 이를 이용해 python의 split 함수를 구현 할 수 있다.
11718,14910과 같음
10086,none
09610,none
02587,none
02511,none
10768,none
10976,none
11719,11718과 사실상 같은 문제
02153,소수를 구하는 for문을 돌릴때 조건문을 반드시(int i=2;i<=sqrt(sum);i++)로 할껏.
17496,n일 문제에서 i일에 시작하면 나눌때 n에서 i일을 빼줄것?
10156,none
02965,해당 문제 빨리 푸는 법:C-B-1>B-A-1?C-B-1:B-A-1
04999,none
14429,an과 공차 r을 알고 있을때의 n:(an/r)+1
20973,(a+b)의 3중 for문 반복 횟수:(b+c)*((c+b)*(c+b-1)/2)/단순히 a번 반복은 while(a--)로도 할 수 있다. 단, --a는 오류를 일으킨다.
01924,요일 계산법/*를 이용하면 char로도 문자열 배열을 받을 수 있다.
16431,최소거리:대각선 가능할 경우 대각선 거리/직선으로만 움직일 경우 각 죄표의 절대값 차
10103,none
01453,none
19944,none
10569,none
05086,none
01408,시간을 계산할때 작은 단위부터 계산할것.
02609,최대공약수와 최소공배수
10989,메모리를 아낄려면 일일히 배열을 저장하는것이 아닌 출현 수를 세서 for문을 돌릴것.그러나 시간이 많이 잠아먹음
10814,vector의 전반적인 사용법/vector liter는 포인터로 *을 사용해야 한다.
11913,(py)sys를 이용해 python에서도 stdin/stuout을 사용할 수 있다.
02231,분해합
01181,(py)key=lambda x:(len(x);;x):길이순으로 먼저 정렬후 사전순으로 정렬
02581,(py) 분수를 이용해 sqrt import 없이도 제곱근 계산 가능
11651,(py)list로 복수의 값을 받는 방법
04673,(py)셀프 넘버 구하는 법/list 등의 for문을 넣으므로써 증가하는 수열을 넣을수 있다
11655,for(char &b:a)식으로 돌릴때 b를 수정하면 a도 수정된다
02941,항상올림되는 식 a/b=c에서 a의 최솟값:b*(c-1)+1
15727,none
10158,a길이의 c지점을 시작으로 e초동안 왕복했을때의 지점:((c+e)/a)%2?a-(c+e)%a:(c+e)%a
01427,reverse를 쓰지 않고 string을 거꾸로 출력하는 법:     for(auto it = a.rbegin(); it != a.rend(); ++it) {  std::cout << *it; }
01764,(py)set를 이용하면 빠르게 교집합을 구할수 있다.
11399,(py)입출력이 적으면 오히려 input과 print가 아주 약간 더 빠를 수도 있다.
01920,이진 탐색
01065,none
05361,소숫점 뒷자리만 조절:cout << fixed << setprecision(2)
01978,02153과 동일
02740,zip(*a):list의 행과 열을 바꿈.행렬 곱에 유용
15964,none
01475,6과 9를 혼용할수 있을때 6의 개수와 9의 개수를 더한후 1/2값을 뺀다
10845,queue 사용법
01598,몫이나 나머지의 차 계산법
09325,none
01212,8진수 정도는 그냥 배열로 모든 값을 넣어서 해결한다.
15904,index를 찾을떄 algorithm 안에 있는 find 보다 string 안에 있는 find를 쓰는것이 더 좋다.
15668,배열 사이즈에는 제한이 있는것같다.
11050,이항계수=nCr;;c++에서 nCr 구하는 법:for(int i=0;i<k;i++) ans*=(n-i);for(int i=1;i<=k;i++) ans/=i;
13410,to_string과 stoi 사용법
11653,기본적인 소인수 분해 사용법
01120,none
04796,사칙연산 안에서도 삼항연산자를 넣을 수 있다.
01158,vector eraser는 iter 형만 받으므로 a.begin()+int 식으로 써야 한다.
09093,find와 replace 다루는 법.
13458,올림공식은 분자 부분이 음수가 될 경우 오작동 할 여지가 있다. 따라서 삼항연산자로 구분해주어야 한다.
02909,pow함수는 부동소숫점 문제로 int변환시 잘못된 값을 주는 경우가 있음으로 round로 감싸서 int로 넘겨야 한다.
02693,sort
10214,삼항연산자
01003,피보나치 f(n)에서 f(0)의 수:f(n-1)/f(1)의 수:f(n)
05800,점수 관련 문제는 short로 풀어도 되나 채점시 메모리는 그리 줄지 않는다.
01929,소수/bool은 1byte여서 배열로 많이 써도 그리 메모리를 많이 먹지 않는다.
18310,매우 큰 배열에서는 정수형 배열 포인터보다 그냥 최대값을 사용하는것이 오히려 메모리 확보에 도움이 되는것 같다.
01316,none
10773,vector의 pop_back으로 stack을 대체할 수 있음.
01931,new로 2차원 배열 만드는법;;함수에서 2차원 배열을 쓰려면 int* 사용
10825,정렬 함수 작성시 감소하는 순서:a>b/증가하는 순서:a<b
14656,none
01350, new 배열 for문:auto k=b;k<b+a;k++
07785,문자열을 계속 찾아야 하는 경우 map 이나 set 이용
04740,none
10816,굳이 정렬을 할 필요가 없으면 map보다는 unordered_map을 사용하는것이 좋다. 단;;sort 자체가 안됨'
11098,none
11047,none
01977,none
11650,sort에서 2차원 배열을 넣는 방법이 없는거 같다.
01026,sort의 기본 정렬은 less.
10815,vector 사용시 push_back이 소폭 빠르나 메모리는 훨씬 많이 사용한다.
10828,stack
11557,none
07568,(x;; y);; (p;; q)라고 할 때 x > p 그리고 y > q 일때의 순위
10807,count
01758.none
01205,겹치는 등수가 있을때 등수 확인
02935,매우 큰 수 덧셈과 곱셈
02738,행렬의 덧셈;;2차원 벡터 만드는 법
01431,string 정렬 함수 만들때;;vector를 이용하던 동적 배열을 이용하던 매개 함수의 자료형은 string
05653, class 형태를 sort 하는 법
02559,누적 합
02217,none
18110,더하는 동시에 나누는 형식은 값이 많이 투입될수록 오차때문에 값이 달라질수 있다. 다 더하고 한번에 나누는 것이 좋다.
11659,대략 10만개 정도의 입출력을 처리할때 iostream 최적화에 따라 매우 큰 시간차이가 남으로 반드시 써주어야 한다.
15353,매우 큰 수의 덧셈
10826,더욱 빠른 큰 수의 덧셈
16435,none
02851,none
04134,소수
01654,주어진 조건 내에서 최대값을 구할 때 이진탐색 쓰는 법
11170,특정 문자 찾기
01292,수열에서 n에서부터 m까지의 합:부분합 이용
02491,none
01063,아무것도 return 안되는 함수를 만들때에는 반드시 void를 사용할것. int등 다른 것 사용시 withoutreturningerror
02108,음수가 있는 배열에서 최빈값등을 구하려면 배열이 가질수 있는 최대값을 더한뒤 처리후 뺀다.
11866,원형으로 돌아가는 수열 탐색.
02512,01654와 동일
13305,지점과 지점 사이에 비용이 있을때의 최솟값.
11279,우선순위 큐
09324,none
17618,none
11004,sort 자체는 빠른 편.cin이나 cout을 먼저 최적화 할것. 그 뒤 속도를 줄이고 싶으면 이분 탐색 이용.
01302,map에서 가장 많이 나온 key 값 찾기.
11971,none
02164,queue;더 간단한 방법:((입력값) - (2의 n제곱(입력값보다 작은것의 최댓값))) * 2
15649, 경우의 수나 순열 등을 찾을때는 dfs를 이용한다. 
04150,10826과 동일
06378,0입력시 종료:while ((cin>>a)&&a!="0") 
14916,02839와 동일
02805,이분탐색(01654와 동일)
01449,여백 있이 붙여야 하는 테이프의 최솟값
01018,체스판의 경우 행+열이 짝수면 흰색;홀수이면 검은색
09461,dp
11051,(a/b)%k != (a%k)/(b%k);따라서 이항계수의 나머지 등을 구할때는 파스칼의 정리를 dp로 구현하여 풀어야 함.
01357,뒤집어 계산할 때 계속 틀린다면 100->001로 출력되는지 확인한 후 최종 값도 int 화 시킬 것.
10866,deque
02579,dp에 선택지가 있을경우 max나 min으로 해당 단계에서의 최적의 값을 찾아내면 된다.
01463,dp 선택지가 있으면 단순뺄셈->낮은값 순으로 나누기 차례로 min이나 max를 구한다.
01439,find를 활용하여 연속되는 칸들의 개수를 셀 수 있다.
01436,브루트포스
01010,간단한 조합 구하는 법
11758,ccw:3점의 방량을 알아내는 방법으로 (x2-x1)(y3-y1)-(y2-y1)(x3-x1)이 양수면 시계방향;0이면 직선;음수면 반시계방향임.
09095,dp
01932,삼각형 모양의 그래프에서의 합 등을 구할때 dp를 사용하되 모든 경우의 수를 확인해야 한다.
02303,부분 수열을 구하기 위한 다중 for 문을 돌릴때 끝 값은 무조건 배열의 개수이다.
01312,소수점 계산
09656,승패를 따질때 dp 사용법
01049,패키지와 단품이 있을때의 최소 비용 계산
17219,map
11723,set
18291,분할 정복을 이용한 거듭 제곱;(a^b) % c = (a%c ^ b%c) % c
01629,분할 정복을 이용한 거듭 제곱에서 지수가 홀수일때 리턴값:return (x*x%c)*a%c;
01676,팩토리얼에서 0이 아닌 숫자가 나올때 까지의 0의 개수
02003,두 포인터
03207,두 수의 합 찾기
01246,none
01699,제곱수
11726,(sum(a,a+b))%c=a[0]%c+a[1]%c+...+a[n-1]%c
17390,누적합
02470,03207과 동일
01912,누적합을 동적배열로 이용할때 반드시 index 0에 값을 넣어줄것.
11660,2차원 배열에서의 부분 합
04378,sting eof;
16212,none
02193,연속으로 나타나지 않는 문자열이 있을때의 경우의 수
15650,올림차순일때의 dfs
10610,sort
09251,lcs
11652,error났던 이유:연속값이 모두 1일때 ans가 무조건 0이 나왔음.b[0]으로 초기값을 설정해주었어야 함
03135,none
20291,map의 key는 자동으로 정렬되는 특성이 있음.
01543,string find 사용시 end 보다는 npos 사용
01697,dfs
04299,none
01806,두 포인터
01260,dfs 와 bfs;특정 방점을 먼저 지나야 한다면 인접 행렬을 사용하거나 인접 리스트를 sort 해야함;인접 리스트를 사용하는것이 메모리에 도움이 됨
02506,none
15998,수의 크기와 량이 엄청날경우 최대범위의 배열을 만드는것이 오히려 더 좋을수도 있다.
15651,일반적으로 수가 중복될수 있는 백트래킹;dfs;bfs;에는 방문을 체크하는 배열을 만들 필요가 없다.
18870,같은 내용물의 vector가 필요할때, push_back 보다는 배열을 만들때 바로 복사해주는게 시간은 소폭 증가하나 메모리가 대폭 줄어든다;set은 index로 접근이 불가능하다;정확한 원인은 모르겠지만 set을 복사한 vector도 find가 되지 않으므로 vector를 sort후 unique 를 통해 중복제거를 해서 사용하는것이 좋다.
11441,누적 합
04948,특정 구간에서의 소수의 개수를 구할때는 에리스토의 체를 이용한다;정적 배열로 bool을 사용시 count함수가 잘 안될수도 있음;
12851,bfs에서 최적의 가짓수를 세는 방법;int 도 초기화를 안하거나 값이 0이면 bool처럼 취급할수 있음
21919,단순히 해당 숫자가 소수인지를 판별할때에는 sqrt까지 나누어 주는것이 더 빠름
01927,우선순위 큐도 정렬 기준을 다르게 할 수 있다;단 중간에 vector를 추가로 넣어야 함
15652,비내림차순으로 백트랙킹 할 경우.
05046,none
05565,none
01940,두 포인터
01075,none
02606,bfs
17676,01699와 완벽히 동일
02467,02470과 완벽히 동일
01267,초기화 할때 초기값을 반드시 넣어줄것
12865,배낭 문제;동적 배열로 2차원 배열을 만드는 방법