02789,string만으로 for문 돌리기/to_string은 int를 string으로 바꾸는 것:
05717,done
07891,done
11006,기존 int로 for문 돌리기
14645,반복문
20332,done
20361,for문에 for문 내에 써야할 변수는 쓰지 말껏(반복 횟수에 영향을 줌)
20673,done
06376,분수 계산후 형 변환시 분수 감싸지 말것(int로 되버림)/cout.precision(n):cout에서 소수점자리를 최대 n자리 까지 출력/cout.setf(ios::showpoint);소수점 뒷자리의 0표시
10419,sqrt 함수는 cmath 라이브러리에 있음
01731,일반array는 append 불가/append하고 싶으면 vector로 만들고 push_back()/n번 반복을 --로 구현할시 (n;n>0;n--)
02386,string으로 뛰어쓰기 있는 문장 입력하고 싶으면 getline이용/string을 소문자로 바꿀 경우 algorithm에 있는 transform을 이용할수 있음;이때 tolower앞에 반드시 ::붙일것
03047,char로 문자열 받을 경우 반드시 칸수를 (문자열길이)+1으로 할 것
05704,char도 증감 연산 가능/string에서 문자 수를 셀때는 algorithm에 있는 count 함수 이용
01264,count  함수
06322,cout << fixed; 소숫점 자리만 precision 함수를 먹도록 함.
05032,none?
02736,string length
02744,c++에 python의 swapcase 명령어는 없음. 그러나 그 외의 tolower나 islower 같은 명령어는 있음.
01568,증감연산자를 조건문 등에서 조건으로 쓰지 말것.조건에서도 식이 계산되버림.
01094,나눗셈으로도 for문을 돌릴수 있음.
02145,%연산자는 반드시 int 끼리만 연산 가능.cmath의 log10를 이용하면 쉽게 숫자의 자리수를 알 수 있음. 
01259,string을 이등분하게 되면 length가 짝수일시 0~len/2와 len/2+1~len-1로;홀수일시 0~len/2-1와 len/2+1~len-1
02869,c++에서 0.xx초는 반복문을 넣지만 않으면 조건문 몇개정도는 충분히 돌아간다.
01574,20361과 동일
02935,none
05054,배열등에서의 최대값이나 최솟값은 algorithm에 있는 *max;min_elements 함수를 이용한다.
02798,브루트포스=노가다/c++이면 100c3면 삼중 for문 해도 1ms가 날까 말까 임으로 그냥 노가다로 풀자.
02484,*max_elements 함수를 쓸때 int 배열이면 a;;a+n으로 활용한다.
09655,none
01684,string을 비교할시에는 작은 따옴표 대산 큰 따옴표 로 문자열을 감싸야 한다
11320,큰 정삼각형 안에 들어가는 작은 삼각형의 개수:(두 삼각형 변의 비)^2
06559,배열도 string 식으로 for문을 돌릴수 있음.
02739,none
10833,none
10818,vector는 좀...많이 느리다
13866,괄호만 씌어준다면 co다ut에서도 삼항연산자를 사용 할 수 있다.
02495,none
09498,none
11728,cin은 int 일시 개행을 해도 구분 되어 넣는다. 따라서 여러줄을 for문으로 받을수 있다/cin.tie(0);cout.tie(0);ios::sync_with_stdio(0); 로 cin과 cout의 속도를 늘릴수 있다. 딘 scanf하고 printf;; gets;; puts하고 혼용하면 안됨.
02902,none
01271,10^1000승은 c++에서는 정수로 처리할수 없다. 파이썬을 써야 한다
01001,(go)string으로 박고 int로 바꾸는게 더 빠를수도
01001,(py)2개를 한번에 받을때 반드시 string으로 받아야 오류가 나지 않는다
15552,01271번의 cin/cout을 최적화하는 방법을 쓰면 scanf/printf 보다 더 빠르다
02010,none
02884,시간 계산
01546,11728과 동일
02525,시간을 더할때 1440분 이하면 시간을 정리할때 한번만 확인해도 된다.
02588,stoi:string to int
04344,%를 출력하려면 %%로 입력해야 한다
04447,getline으로 문제가 일어나면 getchar로 엔터를 한번 빼주거나 cin.ignore();로 엔터를 무시해줄껏
10930,c++로 md5값을 네이티브로 얻는것이 가능은 하다. 코드가 너무 복잡할뿐
10797,none
10808,none
02941,for문의 변수는 for문 안에서 추가적으로 변경해줄수 있다. 이를 이용해 특정 문자열을 띄어 넘을 수 있다.
01010,조합 계산시 c++은 공식을 재귀로 구현;;python은 math의 comb 함수를 이용할 것
05585,raspberrypi test
10869,none
10430,NONE
04072,단어만 뒤집기:cin으로 단어 단위로 받은 후 reverse 함수 이용/for문으로 뒤에서부터 출력하나 reverse를 이용하나 걸리는 시간은 똑같다.
01193,등차가 1씩 증가하는 배열에서 몇번쨰 찾기:등차의 합 이용
11720,none
15184,(char)를 이용하면 정수를 ascii 코드로 대입하여 출력 할 수 있다./{0;;}으로 배열을 0으로 채울 수 있다.
10809,특정 정수로 배열 채우기:algorithm에 fill_n 이용/for(int a:b)로 정수 배열을 반복할수 있다.
02167,cin속도를 높이는 방법을 사용하면 메모리도 약간 감소한다.
10804,c 배열의 a번째부터 b번째 reverse:reverse(c+(a-1);;c+b)
01551,구분이 공백이 아니면 getline으로 받은후 stoi를 사용한다.
02577,none
02711,none
01157,return 0을 사용해 for문등에서 뒤에 명령들을 수행 하지 않고 종료 시킬 수 있다.
03052,none
02530,%=연산자가 있어 나누는 코드를 줄일 수 있다.
02775,재귀로 구해야 할 것 같은 문제들은 주어진 행이 아닌 구해야 하는 행의 주변을 중심으로 생각해볼껏.
15596,백준에서 함수를 만드는 문제의 경우 제출할 시 가이드 라인이 나온다.for문은 생각보다 빠르다...
02839,특정수들로 몇 번 나눠야 하는지 묻는 이런 문제들은 그냥 while문으로 풀자....
11966,int:2^31/long long:2^63
01159,none
10984,none
02845,none
09012,큐나 스택같은 문제는 문자열을 추가하고 지울수 있는 string의 성질을 이용하면 쉽게 풀 수 있다/string에 char를 더할때는 그냥 a+=b 형식으로 추가 하면 된다.
02292,최소 거리를 구하기 위해 for문을 돌릴시 값을 증가시키기 전에 if문으로 다시 검사할것.
02748,피보나치 수열 빨리 구하는 방법/log2로 int를 써야하는지;;long long을 써야하는지 판별 가능.
02338,(py)정수를 한줄에 하나씩 받으면 int(input())을;;한줄에 두개 이상 받으면 map(int;;input().split())
14209,계산에 필요 없는 수들을 continue 시켜줘도 걸리는 시간은 continue를 시키지 않은 것과 거의 같다.
02455,none
03053,pi가 필요한 문제는 cmath의 M_PI이용할것/택시 기하학에서의 원의 넓이:2*r*r
01934,최소 공배수=(두 값의 곱)/(최대 공약수);/최대공약수는 %를 while문으로 돌림으로써 구할수 있음.
03059,none
09310,--제발 c++도 bigint 지원좀--
03040,none
05622,none
02309,정답이 여러 가지인 경우에는 아무거나 출력하라==하나만 출력 하라.
03004,n번변에 평행히 잘랐을때 최대 조각 개수:(N/2+1)*(N/2+1+N%2))
01284,none
02501,none
01037,모든;;혹은 1과 n을제외한 약수들이 주어졌을때 n구하기:최댓값*최솟값
02442,별찍기 같은 문제를 풀때 출력 형식 오류가 뜨면 0번째에 무조건 공백이 생기는지 확인할것.
14592,none
18301,none
01333,이와 같은 문제는 2중 for문으로 푼다.
07481,02839를 이용하면 아주 쉽게 풀 수 있다.
15829,(py)ord():char to ascii
05596,?연산자의 : 전후로 cout 같은 명령어 1개 정도를 집어넣을 수 있다.
04153,iostream만 include 하여 길게 작성하던;; algorithm등 여러가지를 include 하여 여러 명령어를 사용하던 실행속도나 메모리 면에서 차이가 거의 없다.
01297,비율이 a:b일때 인치수로 높이나 너비 구하기:(a||b)*(인치)/sqrt(a^2+b^2)/이때 sqrt부분은 반드시 실수형 이여야 만 함
19532,연립방정식 ax+by=c&&dx+ey=f 일때 x=(c*e-b*f)/(a*e-b*d);y=(c*d-a*f)/(b*d-a*e);
02675,none
03009,이 문제와 같이 적은 빈도수를 찾는 문제에서는 ^=(xor 연산)으로 코드를 간단히 풀 수 있다.
02920,none
01769,none
11382,none
02480,세 수 a/b/c에서의 최대값 구하기:(a>b ? a>c ? a : c : b>c ? b : c)
01373,string 자체는 iostream만 include 해도 쓸 수 있다.
14652,none
01225,한 자리수 씩 연산을 해야 할때에는 그냥 string으로 받은후 for문을 돌리면 된다.
02908,none
13235,none
03460,none
15080,초 계산:c>d?cout<<(3600*24-c)+d<<"\n":cout<<d-c<<"\n";
18406,none
05543,3개의 값 중 최솟값 찾기:a[0]>a[1]?(a[1]>a[2]?a[2]:a[1]):(a[0]>a[2]?a[2]:a[0]);
14910,변수의 개수가 주어지지 않을 경우 while문에 scanf()!=EOF나 무한 루프 후 마지막에 if(cin.eof()==1)를 넣어서 해결할 수 있다. 단;;이 경우 터미널 등에서 돌릴떄는 윈도우에서는 ^Z;;unix에서는 ^D로 종료시켜야 한다.이는 백준에서는 파일로 채첨해 EOF가 들어가 있지만 터미널에서는 들어가 있지 않기 때문이다.
10039,none
10822,find는 찾을것이 없으면 string::npos를 리턴한다. 이를 이용해 python의 split 함수를 구현 할 수 있다.
11718,14910과 같음
10086,none
09610,none
02587,none
02511,none
10768,none
10976,none
11719,11718과 사실상 같은 문제
02153,소수를 구하는 for문을 돌릴때 조건문을 반드시(int i=2;i<=sqrt(sum);i++)로 할껏.
17496,n일 문제에서 i일에 시작하면 나눌때 n에서 i일을 빼줄것?
10156,none
02965,해당 문제 빨리 푸는 법:C-B-1>B-A-1?C-B-1:B-A-1
04999,none
14429,an과 공차 r을 알고 있을때의 n:(an/r)+1
20973,(a+b)의 3중 for문 반복 횟수:(b+c)*((c+b)*(c+b-1)/2)
01924,요일 계산법/*를 이용하면 char로도 문자열 배열을 받을 수 있다.
16431,최소거리:대각선 가능할 경우 대각선 거리/직선으로만 움직일 경우 각 죄표의 절대값 차
10103,none
01453,none
19944,none
10569,none
05086,none
01408,시간을 계산할때 작은 단위부터 계산할것.
02609,최대공약수와 최소공배수
10989,메모리를 아낄려면 일일히 배열을 저장하는것이 아닌 출현 수를 세서 for문을 돌릴것.그러나 시간이 많이 잠아먹음
10814,vector의 전반적인 사용법/vector liter는 포인터로 *을 사용해야 한다.
11913,(py)sys를 이용해 python에서도 stdin/stuout을 사용할 수 있다.
02231,분해합
01181,(py)key=lambda x:(len(x);;x):길이순으로 먼저 정렬후 사전순으로 정렬
02581,(py) 분수를 이용해 sqrt import 없이도 제곱근 계산 가능